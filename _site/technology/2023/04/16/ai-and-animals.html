<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4" crossorigin="anonymous"></script>
</head>
<body class="text-bg-dark">

        <div class="container-lg"><div class="container-fluid d-flex justify-content-center"><img src="/assets/perm/banner.png" class="img-fluid"></div>
<nav class="navbar navbar-expand-lg px-3 border-bottom border-5 mb-3">

            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarText" aria-controls="navbarText" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse" id="navbarText">
                <ul class="navbar-nav me-auto mb-2 mb-lg-0 fw-semibold fs-5">

                    <li class="nav-item pe-5 text-bg-dark text-uppercase">
                        <a class="nav-link text-bg-dark" href="/">BLUE EARTH</a>
                    </li><li class="nav-item pe-5 text-bg-dark text-capitalize">
                            <a class="nav-link text-bg-dark" href="/about/">About</a>
                        </li><li class="nav-item pe-5 text-bg-dark text-capitalize">
                            <a class="nav-link text-bg-dark" href="/posts/">Posts</a>
                        </li></ul>

                <span class="navbar-text fw-bold text-bg-dark">
                    August 03, 2023
                </span>

            </div>

    </nav><div class="p-3">

                <div id="title-section" class="pb-3">
                    <h1 class="text-uppercase fw-bolder">AI and Animals</h1><h4>By <a href="" class="link-warning">Fergie1234</a> | Apr 16, 2023</h4>
              </div>

            <div class="container-fluid mb-3" style="min-height:300px; background-image:url(/assets/images/computer_cat.jpg);background-size:cover;background-position: center;"></div>
              
            <p>In the 1970s a young gorilla known as Koko drew worldwide attention with her ability to use human sign language. But skeptics maintain that Koko and other animals that “learned” to speak (including chimpanzees and dolphins) could not truly understand what they were “saying”—and that trying to make other species use human language, in which symbols represent things that may not be physically present, is futile.</p>

<p>“There’s one set of researchers that’s keen on finding out whether animals can engage in symbolic communication and another set that says, ‘That is anthropomorphizing. We need to understand nonhuman communication on its own terms,’” says Karen Bakker, a professor at the University of British Columbia and a fellow at the Harvard Radcliffe Institute for Advanced Study. Now scientists are using improved sensors and artificial-intelligence technology to observe and decode how a broad range of species, including plants, already share information with their own methods. This field of “digital bioacoustics” is the subject of Bakker’s 2022 book The Sounds of Life: How Digital Technology Is Bringing Us Closer to the Worlds of Animals and Plants (Princeton University Press).</p>

<p>Scientific American spoke with Bakker about how technology can help humans communicate with creatures such as bats and honeybees—and how these conversations are forcing us to rethink our relationship with other species.
Advertisement</p>

<p><strong>[An edited transcript of the interview follows.]</strong></p>

<p>Can you give us a brief history of humans attempting to communicate with animals?</p>

<p>There were numerous attempts in the mid-20th century to try to teach human language to nonhumans, primates such as Koko. And those efforts were somewhat controversial. As we look back, one view we have now (that may not have been so prevalent then) is that we were too anthropocentric in our approaches. The desire then was to assess nonhuman intelligence by teaching nonhumans to speak like we do—when in fact we should have been thinking about their abilities to engage in complex communication on their own terms, in their own embodied way, in their own worldview.</p>

<p>One of the terms used in the book is the notion of umwelt, which is this idea of the lived experience of organisms. If we are attentive to the umwelt of another organism, we wouldn’t expect a honeybee to speak human language, but we would become very interested in the fascinating language of honeybees, which is vibrational and positional. It’s sensitive to nuances such as the polarization of sunlight that we can’t even begin to convey with our bodies. That is where the science is today. The field of digital bioacoustics—which is accelerating exponentially and unveiling fascinating findings about communication across the tree of life—is now approaching these animals and asking not “Can they speak like humans?” but “Can they communicate complex information to one another? How are they doing so? What is significant to them?” I would say that’s a more biocentric approach, or at the very least it’s less anthropocentric.</p>

<p>Taking a bigger view, I think it’s also important to acknowledge that listening to nature, “deep listening,” has a long and venerable tradition. It’s an ancient art that is still practiced in an unmediated form. There are long-standing Indigenous traditions of deep listening that are deeply attuned to nonhuman sounds. So if we combine digital listening—which is opening up vast new worlds of nonhuman sound and decoding that sound with artificial intelligence—with deep listening, I believe that we are on the brink of two important discoveries. The first is language in nonhumans. And that’s a very controversial statement, which we can dig into. The second is: I believe we’re at the brink of interspecies communication.</p>
<div class="text-light pt-3">

    <h1 class="text-uppercase fw-bold pb-3">Comments</h1>

    <div id="comments">
    </div>

    
      <div id="newlySubmitted">
      </div>
    

      <!--- We wrap our contents with an id so the script tag knows what to look out for -->

      <form class="mb-3" id="commentForm">
          <h2 class="fw-bold">Leave a Reply</h2>
          <div class="form-group">
            
          <input type="text" class="form-control mb-3 border-secondary rounded-0 text-bg-dark" id="inputName" aria-describedby="emailHelp" placeholder="Enter name" name="email">
          </div>

          
          <div class="form-group">

          <div><textarea type="text" class="form-control mb-3 border-secondary rounded-0 text-bg-dark" id="inputComment" placeholder="Enter your comment here..." name="name">
          </textarea></div>

          <!-- Submit button -->

          <div class="d-flex align-items-center flex-row-reverse">
              <button id="btn" type="submit" class="btn btn-light rounded-pill">Post a Comment</button>
              <div class="px-3"><div id="alert" class="spinner-border spinner-border-sm d-none" role="status"></div></div>
          </div>
    </div>
  </div>

  
        

        <!-- This is a modal - this will only show up when we hear back from Apps Script -->


        <div class="modal fade" id="notification" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
          <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
              <div class="modal-header">
                <h1 class="modal-title fs-5" id="exampleModalLabel">Your comment has been posted!</h1>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
              </div>
              <div class="modal-body">
                Please keep the community guidelines in mind when posting comments.
              </div>
              <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
              </div>
            </div>
          </div>

        </div>
        
    </form>

    <div class="alert alert-warning d-none" id="submissionSuccess" role="alert">
      <strong>Comment submitted!</strong>
    </div>

    <!-- Alert -->

    
</div></div><div class="container-fluid text-light py-3" style="background-color: black">

    <div class="container">

        <div class="row justify-content-center">
            <div class="col-4">

                <img src="/assets/perm/bird-pixel.gif">

            </div>
            <div class="col-4 d-flex flex-column justify-content-center">

                <p class="align-self-center text-center">Content brought to you by BLUE EARTH (c) 2023</p><br>
                <p class="align-self-center text-center"><small>For inquiries, contact admin@blue-earth.com</small></p>

            </div>
        </div>

    </div>


</div>


</div>        

    </body>

    <script>

        const page = "/technology/2023/04/16/ai-and-animals"

        // Reading comments script

        // let can declare a variable limited to the scope of a block statement or an expression where it is used, unlike var where it can declare globally
    
        let comments;

        // The contents of the container with id "comments" in the HTML body is placed inside placeholder

        var placeholder = document.getElementById("comments");

        var i = 0;

        // The async function is used to wait for some sort of return -- essentially it has an await inside the function

        async function fet() {
            const res = await fetch("https://script.google.com/macros/s/AKfycbwm7f9RBUxWlG7OgtHpoJqxXHtY6G7a6HplmMLr6iyF6V6JD89OhlPnzbLSabk5ITk9/exec?postId=" + page);

            // Notice here that postId=page (with "page" here being page-1) is the "query" (think of inquiry, i.e. a request)
            // The way the Firebase access has been formulated is that it will specify a path to get our desired data. We already have "/blog_contact/", but because we want to display comments from a specific page ID, we must be precise

            // One way to do things is to fetch *all* the data we have and filter it on the browser side (likely using comments.[page]), but this is not what we want for this task

            // Hence we can pass this variable (we can also write the value as a string, I simply use "page" for easier referall) off to Apps Script, but since we can't just send off a value on its own, we need a key for it.

            // Therefore "postId" is information not important on the browser side, but it is a keyword that Apps Script will look for. If we use the "packaging" analogy, Apps Script will look for the package called "postId". 





            // await is usually used to unwrap promises by passing a Promise as the expression. Using await pauses the execution of its surrounding async function until the promise is settled (that is, fulfilled or rejected). When execution resumes, the value of the await expression becomes that of the fulfilled promise.

            // Here, the return is returned as JSON and passed into the comments

            comments = await res.json();

            // We make a variable called content, which is currently empty

            var content = ""

            /*function timeFormatter (epochDate) {
                const time = new Intl.DateTimeFormat('en-US', {
                hour: 'numeric',
                minute: 'numeric',
                hour12: true
                });

                const formatter2 = new Intl.DateTimeFormat('en-US', {
                month: 'long',
                day: 'numeric',
                year: 'numeric'
                });

                const timeHourMinuteAmPm = time.format(new Date());
                const formatterMonthDayYear = formatter2.format(new Date());
                const date = formatterMonthDayYear + ' at ' + timeHourMinuteAmPm

                return date

            };*/

            // Now, we take each entry in the list, put them in a card, append them, and put them in the content variable we just made

            for (key in comments) {
                i += 1;

                console.log(key);

                var name = comments[key].name; // These are just alternative forms of how you can access the path
                var comment = comments[key]["comment"];

                var options = { year: 'numeric', month: 'long', day: 'numeric', hour: 'numeric', minute: 'numeric', hour12: true };
                // var optionsTime = { hour: 'numeric', minute: 'numeric', hour12: true };
                var date = new Date(comments[key]["date"]);
                var dateDisplayed = date.toLocaleDateString("en-US", options);
                // var timeDisplayed = date.toLocaleDateString("en-US", options);


                // date = timeFormatter(epochDate)

                console.log(name); 
                console.log(comment);
                console.log(dateDisplayed);

                // Creates a variable called card that contains the Bootstrap formatting, and the ${} notation is a string literal that can access a variable inside a string 

                var card = `<div class="card mb-4 border-secondary rounded-0 text-bg-dark">
                    <div class="card-body">
                        <p>
                            <b>${name}</b> says:
                            <br>
                            <small class="text-warning">${dateDisplayed}</small>
                        </p>
                        
                        <p class="mb-2 text-body-secondary">${comment}</p>
                    </div>
                </div>`

                content += card;
                //var newDiv = document.createElement('div');
                //newDiv.innerHTML += `comments (${i}): ${key}`;)
                //placeholder.appendChild(newDiv);

            }

            // Now we put everything we've put inside the content inside the html
            placeholder.innerHTML = content;
            

        }

        fet();




        // Submit comments script

        // We get information on the submit button as well as the alert element

        const btn = document.getElementById('btn'),
        alert = document.getElementById('alert'),
        submissionSuccess = document.getElementById('submissionSuccess')

        // We add an event listener to when the button is clicked...
      
        btn.addEventListener('click', () => {

        // The alert's default state of appearance is "d-none", which hides the element. We remove the d-none so we can show it...
        
        alert.classList.remove('d-none');

        // We wait, then add the d-none property back to the element
        
        setTimeout(() => {
            alert.classList.add('d-none');
        }, 2000)
        
        })


        // We get the element with the id commentForm, and look out for a submit event, which we will execute the postComment function

        document.getElementById('commentForm').addEventListener('submit', postComment);

        //const myModal = document.getElementById('exampleModal')
        //const myModal = new bootstrap.Modal(document.getElementById('exampleModal'));

        // After we execute postComment, we show the Bootstrap Modal

        const myModal = new bootstrap.Modal('#notification');
        
        var placeholderNewlySubmitted = document.getElementById("newlySubmitted")
      

        function postComment (event) {

            // The preventDefault() method cancels the event if it is cancelable, meaning that the default action that belongs to the event will not occur

            event.preventDefault();

            // We store the contents that we've put inside the form in the consts 

            const name = document.getElementById('inputName').value;
            const comment = document.getElementById('inputComment').value;
            const tempDate = "Moments ago"

            /* const time = new Intl.DateTimeFormat('en-US', {
              hour: 'numeric',
              minute: 'numeric',
              hour12: true
            });

            const formatter2 = new Intl.DateTimeFormat('en-US', {
              month: 'long',
              day: 'numeric',
              year: 'numeric'
            });

            const timeHourMinuteAmPm = time.format(new Date());
            const formatterMonthDayYear = formatter2.format(new Date());
            const date = formatterMonthDayYear + ' at ' + timeHourMinuteAmPm*/

            // XMLHttpRequest is a built-in browser object that allows to make HTTP requests in JavaScript

            const XHR = new XMLHttpRequest();

            // We store the commentForm inside the form

            form = document.getElementById('commentForm');

            // Since we have the XMLHttpRequest() inside the XHR const, it looks out for a "load" event, where it would pass the paramater into a function created immediately... 

            var newlySubmittedContent = "";

            function addNewComment(name, comment, tempDate) {
              var newComment = `<div class="card mb-4 border-secondary rounded-0 text-bg-dark">
                    <div class="card-body">
                        <p>
                            <b>${name}</b> says:
                            <br>
                            <small class="text-warning">${tempDate}</small>
                        </p>
                        
                        <p class="mb-2 text-body-secondary">${comment}</p>
                    </div>
                </div>`

                newlySubmittedContent += newComment;
            };

            XHR.addEventListener("load", (event) => {

                // We're expecting a response from Google Apps Script. If we hear OK, then the modal we made should show.

                if (event.target.responseText == "OK") {
                    console.log("modal should show");
                    
                    // myModal.show();

                    newlySubmitted.classList.remove('d-none');

                    addNewComment(name, comment, tempDate);
                    placeholderNewlySubmitted.innerHTML = newlySubmittedContent;
                    form.classList.add('d-none')

                    submissionSuccess.classList.remove('d-none')

                    setTimeout(() => {
                        submissionSuccess.classList.add('d-none');
                        form.classList.remove('d-none');
                    }, 2000)

                    
                    
                    
                    
                    

                    //$('#exampleModal').modal('show');

                }

                else {
                    console.log("Failed to submit comment...");
                }
            });
            

            // We're also looking out for an error

            XHR.addEventListener("error", (event) => {
                alert("Error: " + event.target.responseText);
            });
            
            // FD.append("thisVariableIsForAppsScriptEmail", thisIsMyVariableCalledEmail);
            // FD.append("thisVariableIsForAppsScriptName", thisIsMyVariableCalledName);

            // Here we post whatever we've just sent via POST method...

            XHR.open("POST", "https://script.google.com/macros/s/AKfycbzeTZMlV9a-Tb3VvTJLYoKdK1IBDLhFLsD3Pgv6rrNpo60IpgdWfJmYN03R7RDEiKdfpA/exec");
            
            jsondata = JSON.stringify({
                    "nameAppsScript": name,
                    "commentAppsScript": comment,
                    "pageAppsScript": page
                });
                
            XHR.send(jsondata);

        }</script>
    
</html>

